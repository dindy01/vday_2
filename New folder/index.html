<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A Valentine's Journey</title>
    <style>
        /* 
         * DESIGN SYSTEM & VARIABLES 
         * Soft, minimalist palette.
         */
        :root {
            --bg-color: #fff0f3;       /* Very pale pink */
            --primary: #d64045;        /* Soft red */
            --primary-hover: #b52b30;
            --text-color: #4a4a4a;     /* Soft dark gray */
            --wall-color: #ffd1d6;     /* Darker pink for maze walls */
            --path-color: #ffffff;     /* White for maze paths */
            --player-color: #d64045;   /* Red dot */
            --goal-color: #ff99ac;     /* Lighter pink goal */
            
            --font-main: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --transition-speed: 0.5s;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none; /* Prevent selection while playing */
        }

        body {
            font-family: var(--font-main);
            background-color: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            width: 100vw;
            overflow: hidden; /* Prevent scrolling */
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        /* 
         * LAYOUT CONTAINERS 
         */
        #app {
            width: 100%;
            max-width: 600px;
            padding: 20px;
            position: relative;
        }

        /* Generic Screen Class - handles transitions */
        .screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            opacity: 0;
            pointer-events: none;
            transition: opacity var(--transition-speed) ease-in-out;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1.5rem;
        }

        .screen.active {
            opacity: 1;
            pointer-events: all;
        }

        /* 
         * TYPOGRAPHY & UI ELEMENTS 
         */
        h1, h2 {
            font-weight: 300;
            color: var(--primary);
            margin-bottom: 0.5rem;
        }

        p {
            font-size: 1.1rem;
            line-height: 1.6;
            max-width: 400px;
            margin: 0 auto;
        }

        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 12px 32px;
            font-size: 1rem;
            border-radius: 50px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 4px 6px rgba(214, 64, 69, 0.2);
        }

        button:hover {
            background-color: var(--primary-hover);
        }

        button:active {
            transform: scale(0.98);
        }

        /* 
         * MAZE STYLES 
         */
        #maze-container {
            display: grid;
            gap: 2px;
            background-color: var(--bg-color);
            border: 4px solid var(--wall-color);
            border-radius: 8px;
            margin: 0 auto;
            position: relative;
            /* width set dynamically in JS */
        }

        .cell {
            width: 25px;
            height: 25px;
            border-radius: 2px;
        }
        
        /* Responsive cell size */
        @media (max-width: 400px) {
            .cell { width: 20px; height: 20px; }
        }

        .wall { background-color: var(--wall-color); }
        .path { background-color: var(--path-color); }
        
        .goal { 
            background-color: var(--goal-color); 
            animation: pulse-goal 2s infinite;
            border-radius: 50%;
            transform: scale(0.8);
        }

        .player {
            position: absolute;
            background-color: var(--primary);
            border-radius: 50%;
            transition: top 0.1s linear, left 0.1s linear;
            z-index: 10;
        }

        #timer-display {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary);
            height: 30px; /* Preserve space */
        }

        /* 
         * ON-SCREEN CONTROLS (Mobile)
         */
        #controls {
            display: none; /* Hidden on desktop by default */
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }

        @media (hover: none) and (pointer: coarse) {
            #controls { display: grid; }
        }

        .control-btn {
            width: 50px;
            height: 50px;
            background: white;
            border: 2px solid var(--wall-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: var(--primary);
            cursor: pointer;
        }

        .control-btn:active { background: var(--wall-color); }

        /* 
         * FINAL SCREEN ANIMATIONS 
         */
        .heart-big {
            font-size: 4rem;
            color: var(--primary);
            animation: heartbeat 1.5s infinite;
        }

        @keyframes pulse-goal {
            0% { transform: scale(0.7); opacity: 0.8; }
            50% { transform: scale(0.9); opacity: 1; }
            100% { transform: scale(0.7); opacity: 0.8; }
        }

        @keyframes heartbeat {
            0% { transform: scale(1); }
            15% { transform: scale(1.15); }
            30% { transform: scale(1); }
            45% { transform: scale(1.15); }
            60% { transform: scale(1); }
            100% { transform: scale(1); }
        }

        .btn-group {
            display: flex;
            gap: 20px;
        }

        .hidden { display: none; }
    </style>
</head>
<body>

    <div id="app">
        
        <!-- SCREEN 1: ENTRY -->
        <section id="screen-entry" class="screen active">
            <div class="heart-big">♥</div>
            <h1>A Little Journey</h1>
            <button onclick="Game.startLevel(0)">Start</button>
        </section>

        <!-- SCREEN 2: NARRATIVE INTRO -->
        <section id="screen-intro" class="screen">
            <h2 id="intro-title">Level 1</h2>
            <p id="intro-text">...</p>
            <button onclick="Game.enterMaze()">Begin</button>
        </section>

        <!-- SCREEN 3: GAMEPLAY (MAZE) -->
        <section id="screen-game" class="screen">
            <div id="timer-display"></div>
            
            <div id="maze-container">
                <!-- Grid generated by JS -->
                <!-- Player generated by JS -->
            </div>

            <!-- Mobile Controls -->
            <div id="controls">
                <div></div>
                <div class="control-btn" onclick="Game.movePlayer(0, -1)">▲</div>
                <div></div>
                <div class="control-btn" onclick="Game.movePlayer(-1, 0)">◀</div>
                <div class="control-btn" onclick="Game.movePlayer(0, 1)">▼</div>
                <div class="control-btn" onclick="Game.movePlayer(1, 0)">▶</div>
            </div>
        </section>

        <!-- SCREEN 4: REWARD -->
        <section id="screen-reward" class="screen">
            <div class="heart-big" style="font-size: 2rem;">♥</div>
            <p id="reward-text">...</p>
            <button onclick="Game.nextLevel()">Continue</button>
        </section>

        <!-- SCREEN 5: FINAL QUESTION -->
        <section id="screen-final" class="screen">
            <div class="heart-big">♥</div>
            <h2>Will you be my Valentine?</h2>
            <div class="btn-group">
                <button onclick="Game.finish('yes')">Yes</button>
                <button onclick="Game.finish('ofcourse')">Of course</button>
            </div>
        </section>

        <!-- SCREEN 6: SUCCESS -->
        <section id="screen-success" class="screen">
            <div class="heart-big">♥</div>
            <h2>Happy Valentine's Day!</h2>
            <p>I can't wait.</p>
        </section>

    </div>

    <script>
        /**
         * CONFIGURATION & DATA
         * Modify the rewards below to customize the experience.
         */
         const MAZE_CONFIG = [
            {
                // LEVEL 1
                intro: "Moving forward is easier when you know the destination.",
                reward: "Next stop: A Surprise Dinner at Mario's", // <--- CHANGE THIS
                hasTimer: false,
                // 1 = Wall, 0 = Path, 2 = Start, 3 = Goal
                map: [
                    [1,1,1,1,1,1,1,1,1,1],
                    [1,2,0,0,1,0,0,0,0,1],
                    [1,1,1,0,1,0,1,1,0,1],
                    [1,0,0,0,0,0,1,0,0,1],
                    [1,0,1,1,1,1,1,0,1,1],
                    [1,0,0,0,0,0,0,0,3,1],
                    [1,1,1,1,1,1,1,1,1,1]
                ]
            },
            {
                // LEVEL 2
                intro: "Knowing where isn't enough. Timing matters.",
                reward: "The clock is set: Friday at 8:00 PM", // <--- CHANGE THIS
                hasTimer: true,
                seconds: 15,
                map: [
                    [1,1,1,1,1,1,1,1,1,1,1],
                    [1,2,0,0,0,0,1,0,0,0,1],
                    [1,0,1,1,1,0,1,0,1,0,1],
                    [1,0,1,0,0,0,0,0,1,0,1],
                    [1,0,1,0,1,1,1,1,1,0,1],
                    [1,0,0,0,1,3,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,1,1]
                ]
            },
            {
                // LEVEL 3
                intro: "No more planning. Just enjoy the moment.",
                reward: "There’s just one question left.",
                hasTimer: false,
                // A very open, easy map
                map: [
                    [1,1,1,1,1,1,1,1],
                    [1,2,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,3,1],
                    [1,1,1,1,1,1,1,1]
                ]
            }
        ];

        /**
         * GAME ENGINE
         */
        const Game = {
            currentLevel: 0,
            playerPos: { x: 1, y: 1 },
            isInputBlocked: false,
            timerInterval: null,
            timerValue: 0,

            // DOM Elements
            elEntry: document.getElementById('screen-entry'),
            elIntro: document.getElementById('screen-intro'),
            elGame: document.getElementById('screen-game'),
            elReward: document.getElementById('screen-reward'),
            elFinal: document.getElementById('screen-final'),
            elSuccess: document.getElementById('screen-success'),
            
            elMazeContainer: document.getElementById('maze-container'),
            elTimerDisplay: document.getElementById('timer-display'),
            elIntroText: document.getElementById('intro-text'),
            elRewardText: document.getElementById('reward-text'),

            init() {
                // Keyboard listeners
                document.addEventListener('keydown', (e) => {
                    if (this.isInputBlocked) return;
                    // Prevent default scrolling for arrows
                    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) {
                        e.preventDefault();
                    }

                    switch(e.key) {
                        case 'ArrowUp': this.movePlayer(0, -1); break;
                        case 'ArrowDown': this.movePlayer(0, 1); break;
                        case 'ArrowLeft': this.movePlayer(-1, 0); break;
                        case 'ArrowRight': this.movePlayer(1, 0); break;
                    }
                });
            },

            // Helper to switch screens with fade
            switchScreen(newScreenEl) {
                // Find currently active screen
                const active = document.querySelector('.screen.active');
                if (active) active.classList.remove('active');
                
                // Small delay to allow fade out, then fade in new one
                setTimeout(() => {
                    newScreenEl.classList.add('active');
                }, 500);
            },

            startLevel(levelIndex) {
                this.currentLevel = levelIndex;
                const config = MAZE_CONFIG[levelIndex];

                // Set Intro Text
                this.elIntroText.innerText = config.intro;
                this.switchScreen(this.elIntro);
            },

            enterMaze() {
                this.buildMaze(this.currentLevel);
                this.switchScreen(this.elGame);
                this.isInputBlocked = false;

                const config = MAZE_CONFIG[this.currentLevel];
                
                // Handle Timer
                clearInterval(this.timerInterval);
                this.elTimerDisplay.innerText = "";
                
                if (config.hasTimer) {
                    this.timerValue = config.seconds;
                    this.elTimerDisplay.innerText = `Time: ${this.timerValue}`;
                    this.timerInterval = setInterval(() => {
                        this.timerValue--;
                        this.elTimerDisplay.innerText = `Time: ${this.timerValue}`;
                        if (this.timerValue <= 0) {
                            this.resetMaze();
                        }
                    }, 1000);
                }
            },

            buildMaze(levelIndex) {
                const map = MAZE_CONFIG[levelIndex].map;
                this.elMazeContainer.innerHTML = ''; // Clear previous

                const rows = map.length;
                const cols = map[0].length;

                // Set grid styles dynamically
                this.elMazeContainer.style.gridTemplateColumns = `repeat(${cols}, auto)`;
                this.elMazeContainer.style.width = 'fit-content';

                // Render grid
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        
                        const val = map[y][x];
                        
                        if (val === 1) cell.classList.add('wall');
                        else cell.classList.add('path');

                        if (val === 2) {
                            this.playerPos = { x, y }; // Set start pos
                        }
                        if (val === 3) {
                            const goal = document.createElement('div');
                            goal.classList.add('cell', 'goal');
                            // We overlay the goal div on top or inside the cell
                            // Easier: just style the cell as goal
                            cell.classList.remove('path');
                            cell.classList.add('goal');
                        }

                        // Add coordinate data for logic
                        cell.dataset.x = x;
                        cell.dataset.y = y;
                        this.elMazeContainer.appendChild(cell);
                    }
                }

                // Create Player Element
                this.playerEl = document.createElement('div');
                this.playerEl.classList.add('cell', 'player');
                this.elMazeContainer.appendChild(this.playerEl);
                
                this.updatePlayerVisuals();
            },

            updatePlayerVisuals() {
                // We use pixel translation to move the absolute player div
                // Get the size of a cell (handling responsive resizing)
                const firstCell = this.elMazeContainer.querySelector('.cell');
                const size = firstCell.offsetWidth; // width/height including border/padding
                const gap = 2; // CSS Grid Gap

                const top = this.playerPos.y * (size + gap);
                const left = this.playerPos.x * (size + gap);

                this.playerEl.style.top = `${top}px`;
                this.playerEl.style.left = `${left}px`;
                
                // Match size just in case
                this.playerEl.style.width = `${size}px`;
                this.playerEl.style.height = `${size}px`;
            },

            movePlayer(dx, dy) {
                if (this.isInputBlocked) return;

                const newX = this.playerPos.x + dx;
                const newY = this.playerPos.y + dy;
                const map = MAZE_CONFIG[this.currentLevel].map;

                // Boundary check
                if (newY < 0 || newY >= map.length || newX < 0 || newX >= map[0].length) return;

                // Wall check (1 is wall)
                if (map[newY][newX] === 1) return;

                // Move
                this.playerPos = { x: newX, y: newY };
                this.updatePlayerVisuals();

                // Win check (3 is goal)
                if (map[newY][newX] === 3) {
                    this.levelComplete();
                }
            },

            resetMaze() {
                // If time runs out, just reset position, don't show text
                // Find start pos
                const map = MAZE_CONFIG[this.currentLevel].map;
                for(let y=0; y<map.length; y++) {
                    for(let x=0; x<map[0].length; x++) {
                        if(map[y][x] === 2) {
                            this.playerPos = { x, y };
                        }
                    }
                }
                this.updatePlayerVisuals();
                // Reset timer
                this.timerValue = MAZE_CONFIG[this.currentLevel].seconds;
                this.elTimerDisplay.innerText = `Time: ${this.timerValue}`;
            },

            levelComplete() {
                this.isInputBlocked = true;
                clearInterval(this.timerInterval);

                setTimeout(() => {
                    const config = MAZE_CONFIG[this.currentLevel];
                    
                    if (this.currentLevel === 2) {
                        // Special transition for last level
                        this.elRewardText.innerText = config.reward;
                        this.switchScreen(this.elReward);
                    } else {
                        this.elRewardText.innerText = config.reward;
                        this.switchScreen(this.elReward);
                    }
                }, 300);
            },

            nextLevel() {
                const nextIdx = this.currentLevel + 1;
                if (nextIdx < MAZE_CONFIG.length) {
                    this.startLevel(nextIdx);
                } else {
                    // Go to Final Question
                    this.switchScreen(this.elFinal);
                }
            },

            finish(response) {
                // Both buttons lead to success
                this.switchScreen(this.elSuccess);
            }
        };

        // Initialize Game
        Game.init();

    </script>
</body>
</html>